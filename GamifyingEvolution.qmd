---
title: "Gamifying Evolution"

format: html
---

## Abstract

## Introduction

### Evolution and Public Acceptance of Science

Of all the topics that represent public misconceptions about science, evolution is perhaps the most vexing to solve (though climate change is emerging as a new front runner in this dubious race). Acceptance of evolution is particularly low in the United States [19], and educators often face direct opposition to teaching evolution in their classrooms. The many opponents of evolution also intentionally spread demonstrably false information and have powerful lobbying capabilities. 

Evolution is a concept that can be difficult to present in a formal learning setting but is very understandable when directly observed.  Engaging games and simulations could therefore be particularly beneficial in helping to reach students and in correcting pervasive public misconceptions about the discipline. 

Previous "evolutionary" games Game designers have long recognized the potential of evolution to SELL games [20]. Frustratingly, the most successful commercial games that emphasize evolution (for example, Spore™, Evolve™, and Pokemon™ Evolution) aren't evolutionary at all. Most of these games insert player choice into the "evolutionary" process, allowing for example, the player's character to choose whether to "evolve" a beak, or a lightning attack. This approach inadvertently represents intelligent design, a pseudoscientific reskinning of young earth creationism. These games, which use evolution as a marketing angle, potentially exacerbate the public's confusion about evolution and reinforce existing misconceptions.

Intelligent Design: An Evolutionary Sandbox (available on Steam) is an evolutionary game in which players create species that are placed in an evolving ecosystem - once released, the creatures continue to evolve on their own. Niche (available on Steam) is a turn-based game in which the player breeds members of a species to avoid extinction. Although they have not been released commercially, the game NeuroEvolving Robotic Operatives (NERO) and a spin-off, EvoCommander, are also examples of games that incorporate evolution [23, 24, 25]. In Galactic Arms Race evolution is used to procedurally generate new weapons for the player [20], and evolutionary computation researchers have successfully tied the evolution of evolved fire patterns in Galactic Arms Race to the background music [26, 27]. 


### Polymorphic Games

Polymorphic Games is an interdisciplinary game studio on the UI campus. Polymorphic Games employs a unique development approach, in which undergraduates from a wide range of disciplines (including Computer Science, Virtual Technology and Design, Biology, English, Theater, Education, Business, and Music) collaborate to create video games that incorporate evolution as a core game mechanic. We were motivated to create Polymorphic Games by the idea that evolution makes a game better -- more compelling and more fun -- because the game adapts to the player. We argue that this approach represents a positive combination of STEM engagement and informal learning. Given a compelling game, players are inherently motivated to learn the underlying evolutionary concepts in order to succeed at the game objectives. Thus, the goal of Polymorphic Games is to make fun and compelling games, and to use established tools (e.g. in-game achievements, Easter eggs, challenges, and missions) to increase the games' educational impact. 

Polymorphic Games' first project was Darwin's Demons, a "space shooter" game inspired by Space Invaders. In Darwin's Demons, the player battles an evolving population of aliens (Figure 1). The enemies' traits are encoded by a digital genome of real numbers, and the fittest enemies reproduce to create the next generation causing the population to adapt to the player. The name of the game was inspired by the Darwinian Demon metaphor, which describes an organism that can evolve without constraint. In Darwin's Demons, each trait can evolve independently (there are no evolutionary tradeoffs), meaning that eventually the player will lose. The objective (like in Space Invaders) is to beat the high score. Players can choose from a wide range of ships and secondary equipment, which increases player interest and serves to drive evolution along different trajectories [28]. Players can upgrade their equipment between generations of enemies, which are the evolutionary equivalent of waves in a typical video game. The up-grade screen includes data on the evolutionary trajectory of the game (Figure 2). The game saves the genome of every creature as a .csv file, allowing experimentation and in-depth analysis of the creatures' evolution in response to player strategy. Development on Darwin's Demons began in May 2016, and the game was released for sale on Valve's Steam platform on February 13, 2017 (the Monday after Darwin Day). To our knowledge, Darwin's Demons was the first commercially released game to fully feature evolving enemies.

Figure 1: Left: A screenshot from Polymorphic Game's first commercial video game Darwin's Demons, in which the player battles an evolving population of enemies. Right: The upgrade screen in Darwin's Demons, which graphs the evolution of game traits. 


Polymorphic Games' second commercial release was Project Hastur, an evolutionary tower defense game. Project Hastur features fully realized 3D game environments and is the first implementation of our evolutionary procedural generation approach. All the game enemies are encoded by a digital genome, and mutations of this genome can produce a startling array of phenotypes. In Project Hastur, the player can play through a campaign that features 14 unique maps that unlock a series of defensive capabilities. The game features its own story, a wide variety of upgrade choices, and many fun "Easter Eggs" about evolution. In this game, our student developers created a method for evolutionary procedural generation of game enemies. All of the creatures in the game have the same architecture of their digital genomes (62 genes encoded by real numbers). These genomes are converted in the Unity Engine to different morphologies, behaviors, colors, and other game traits. This approach can produce a startling diversity of enemy types (Figure 2).

Project Hastur also features experiment mode, in which the evolutionary parameters can be altered. This feature has numerous benefits -- it allows exploration of the system on which the game is built and allows the player to autonomously test "cause and effect" as they adjust parameters. 

Figure 3: Experiment Mode in Project Hastur allows the user to manipulate a wide variety of game features, including the components of the evolutionary model. Importantly, users can deactivate the fitness functions, making the game "non-evolutionary". This serves as an important control setting when testing the educational impact of our games.

*Development:*  Project Hastur is a tower defense video game developed by students in the Polymorphic Games studio at the  University of Idaho.   The game features a campaign of 16 original game maps, as well as an experiment mode (described below) that allows the game to serve as a simulation model.  Project Hastur was released on the Steam game site on Feb 12th, 2019.  The unique feature of Project Hastur is that the enemies in the game model a finite population defined by digital genomes of quantitative traits.

*Gameplay:*  In Project Hastur, the player must defend their base against waves of enemies called the Protean Swarm.  The player defends their base by placing defensive towers in strategic locations, and the towers each have different capabilities, strengths, and weaknesses.  In campaign mode, the player unlocks new game maps and defensive capabilities as they proceed through the story.  Each map is defined by victory conditions that involve defeating a set number of enemy generations or building their defenses to specific criteria.  Enemies appear in “waves”, a classic trope of tower defense games in which the developers script the number and type of enemies that appear over the course of the level.  In Project Hastur, however, the enemy waves are part of a generational evolutionary model - each new enemy wave is comprised of the offspring of the most successful parents in the previous wave.  In this way, we programmed Project Hastur to become an evolutionary tower defense game in which the enemy population adapts as the game proceeds.

The defensive capabilities of the player include four different categories of tower with qualitative differences in how they interact with the physics engine of the game.  These include kinetic, ice, flame, and acid based towers, with each category including 4 different versions of upgrades.  In addition, the player can access and upgrade two different abilities that are activated on demand with a cooldown - robotic minions and airstrikes.

The "gamification" of evolution can potentially help expose players to real evolutionary models in an engaging way.  However, there are several tradeoffs between fun and realism that should be addressed when developing an evolutionary video game.  In this paper, we discuss the lessons learned from developing and releasing games that feature evolution as a core mechanic, and the design decisions inherent to balancing fun gameplay with scientific realism.


### Evolution as a Game Mechanic

The best way to explain the concept is to frame our video games in the context of the "ingredients" of evolution:

-   Variation
-   Inheritance
-   Selection
-   Time

When these components are present, it leads to Adaptation.

#### Variation

Think about the enemies in the old school video games that I used to play in arcades. Space Invaders, Asteroids, Centipede, Tempest, etc. What kinds of variation can you describe in these enemies? In Space Invaders, you had three types of aliens in each wave, plus the occasional bonus flying saucer. In Centipede and Tempest, you actually had categorically different enemy types that varied in how they looked and in their capabilities. Below you can see a few examples of what I mean:


## Space Invaders

![Screenshot of the original Space Invaders](SpaceInvaders.png){.left} Enemy variation in Space Invaders includes the shape of each alien type (four types), but also their position in the armada (each type has its own row) and their speed of movement (which is adjusted based on how many remain in each wave). For now, we will ignore the flying saucer that passes across the top of the screen. The game increases in difficulty by having the movement speed of each wave increase. Ironically, the increased movement speed of the aliens within a wave as the population size was reduced was an unintended function of the increased frame rate achieved by having fewer aliens draw calls.

## Centipede

![Enemies in Centipede](centipede.gif){.left} Centipede includes [enemy types](https://www.retrogamedeconstructionzone.com/2020/08/the-characters-of-centipede.html){target="\"_blank"} with very different behaviors and abilities. The segmented centipede can split into component parts. Fleas drop vertically, leave a trail of mushrooms, and take two hits to destroy. Spiders move in a diagonal zig zag pattern. Scorpions move horizontally across the screen and turn mushrooms poisonous. Each wave the game difficulty increases by changing the behavior and segment number of the centipede.

## Tempest

![](Tempest.png){.left} While not as famous as Space Invaders or Centipede, Tempest was one of my favorite games in the early 80s. The player navigated their ship across various geometric shapes, shooting at different types of enemies with different capabilities. These included player capturing Flippers, lane electrifying Pulsars, and obstacle creating Spikers. So many quarters gone...


This variation is a big part of what makes video games exciting. The difficulty in video games is usually increased over time by introducing new variations of enemies, changing the enemies' capabilities (like speed or fire rate) over time, or increasing the number of enemies. The problem (as we see it) is that these variations are introduced as part of a script that is programmed and balanced by the game developers. Beating the game means memorizing the script.

*Variation:* When the game begins, Protean trait values are instantiated using the starting values in table x with some variation drawn from a Gaussian distribution.  This creates the standing genetic variation in the population upon which selection will act.  When offspring are created (described below), additional mutational variance is introduced.  In campaign mode, the per locus mutation rate and effect size vary depending on the map’s degree of difficulty - more mutational variance causes the game to become much more difficult.  In experiment mode, mutation rate and effect size are determined by the user.  MUTATION RATE (u) is defined as the per locus probability that the genetic value of the locus will be changed by a number drawn from a Gaussian distribution with mean zero and standard deviation defined by the variable MUTATION EFFECT SIZE (e).

When implementing evolution as a game mechanic, we encode variation of enemy traits using a digital representation of a genome.  This variation can be classified into two categories, Standing Genetic Variation and Mutational Variation.  Standing genetic variation is the genetic differences among individuals at the start of the game.  This can be adjusted as design principles dictate, but a general rule of thumb is that more variation in the initial population corresponds to a faster rate of adaptation in the early phases of the game.  Were the game to proceed solely using the standing genetic variation present at the beginning, the combination of selection and random genetic drift would result in a genetically and phenotypically homogeneous population in rather short order.  The resultant lack of variation in the population would quickly engender boredom in the player.

Mutational processes can be used each generation to introduce new genetic variation upon which selection can act.  This is akin to adding more "fuel" to the process of adaptation, sustaining the evolutionary game play much longer than one would observe with only standing genetic variation.  We typically use a mutational step between generations, mutating the digital gametes passed on by the parents to their descendents in the next generation.  It is here that we must acknowledge a tension between designing a game for fun and creating an accurate evolutionary simulation.  Mutation rates in biological populations are well studied, and rates range between 1 in 10^6 and 1 in 10^9 per locus.  These rates are much too low to make for very compelling game play.  In our games, we typically use mutation rates that are much higher than those found in nature.  This accelerates the infusion of mutational variance into the population.

It is important to note that the amount of genetic variation in the population tends to scale with game difficulty.  In our previous games, we have used the rate and effect size of new mutations as one of the key differentiators between modes of difficulty.


Example 2: Using mutational processes to scale difficulty (Darwin's Demons)

#### Inheritance

**The addition of an inheritance model is the primary differentiator in our games that creates adaptation.**

In most games, there is no relationship between enemies within a wave or between waves. They are instantiated (spawned) with developer defined traits at a specified rate, location, and time (or level or wave). This is the key difference in the games that our lab creates. In our games, the enemies traits are specified by digital genomes that they pass on to their offspring through a form of reproduction. If the enemy has a speed value of 4, that means that when it reproduces, its offspring inherit that speed value of 4. Most of the games we work on specify about 40 to 80 "genes" in the enemy genome, each of which can influence one or more game traits such as speed, fire rate, morphology, behavior, health, armor, resistances, etc.

*Protean Traits:*  Each individual in the enemy population is defined by a digital genome of real numbers.  There are 80 genes in the genome.  Each Protean is diploid, such that its final trait value is calculated as the sum of the genetic values for the given locus on each chromosome.  While all of these genes are used by the game engine to render a wide variety of visually distinct game enemies (see Figure x), some of the genes also affect Protean traits that are relevant to game play.  These are the traits upon which the analyses in this paper were performed, and are defined in Table x.


*Inheritance:*  Each “wave” of Proteans in Project Hastur is actually a discrete generation of enemies created from the previous generation using a tournament selection algorithm.  Proteans that are selected as parents (see Tournament Selection, below for the algorithm) each contribute one of their chromosomes, determined randomly, for each locus.  Project Hastur uses a free recombination model (each locus acts as its own chromosome), but the game can specify a customized matrix of recombination frequencies among loci if the user desires.  The chromosomes passed to the offspring are each passed to the mutation algorithm, and each locus has a chance (specified by u) to receive a mutation.  Once the new offspring’s genome is instantiated, it is passed to the population for the next generation.  Project Hastur records the unique ID numbers for each parent of every Protean. Proteans reproduce sexually, but are encoded as hermaphrodites.  

On game maps that contain civilians, Proteans can also reproduce using an asexual model.  In this case, if a Protean kills a civilian the Protean clones itself.  This cloning process produces an offspring that is genetically identical to its parent during the gameplay phase itself (rather than waiting until the end of the wave).  The number of clones produced by this process depends on the parent’s size (COLLIDER SURFACE AREA).  Smaller Proteans produce more clones than larger Proteans.

#### Selection

Selection occurs when there is a correlation between a trait (say... hit points or movement behavior) and **Fitness**. In biological populations, `Fitness` is usually defined in terms of the number of offspring produced by a given individual. We often measure proxies for fitness in empirical biology that are typically predictive of (or at least correlated with ) `Fitness`, such as seed set in plants, survivorship, or number of eggs. In our games, we can make explicit linkages between performance and fitness using `Fitness Functions`.

For example, in Darwin's Demons the enemies accrue `Aggression` by moving downward on the screen. The closer they get to the bottom, the higher their `Aggression` score. if they move past the player and off the bottom of the screen, their `Aggression` score gets an even larger boost. After each wave, the enemies with the highest `Aggression` score also have the highest probability of mating and producing offspring. Thus, we have created an explicit link in which `Aggression` is correlated with `Fitness` (number of offspring). Our games often have more than one of these `Fitness Functions`. For example, the Protean Swarm in Darwin's Demons can also increase their mating chance with `Accuracy` (which measures how often they shoot at the player and how close they came to hitting the player) and `Lifetime` (which measures how long they last on the screen) .

If we turn off the fitness functions, then after each wave the enemies undergo random mating. Adaptive evolution does not occur, but the enemy traits might still evolve randomly because of Random Genetic Drift.



    


*Selection:*  Project Hastur specifies two fitness functions that determine the probability that Proteans will be selected to reproduce at the end of each generation.  The first Fitness Function, called BASE FITNESS  is related to the player’s base.  This is a number that specifies the closest distance to the player base that was achieved by a given Protean.  Should the Protean get right next to the base (a distance of zero), then BASE FITNESS includes the DAMAGE the Protean does to the base.  Lower BASE FITNESS values increase the probability of reproduction when the wave ends.  TOWER DAMAGE is the other fitness function used to calculate whether an individual will reproduce.  In this case, the game sums the total DAMAGE done by the Protean to any defensive structure.  TOTAL FITNESS is calculated by subtracting TOWER DAMAGE from BASE FITNESS.

*Tournament Selection:*  At the end of each generation, we use tournament selection to identify individuals that will serve as parents.  To do this, the game randomly selects a sample of Proteans from the previous generation.  The number of individuals in this sample is a controllable parameter in experiment mode called TOURNAMENT SIZE.  The individual with the best (lowest) value for TOTAL FITNESS is selected as a parent.  A new tournament is then conducted to select the mate.  Reproduction then occurs as described above and a single offspring is passed to the population for the next generation.  This process is repeated until the population in the next generation has a number of individuals in it equal to POPULATION SIZE.   

*Time:*  Over the course of each wave (defined in terms of generations), the Proteans with the trait values that best enable them to navigate the map, damage player defenses, and reach the player base will accrue the best values for fitness.  Each generation then, the most fit Proteans will have the most offspring, and the multivariate trait distribution of the population will change.  This process of adaptation is what we hoped to encode into a tower defense game, and this paper represents our attempt to test the hypothesis that Project Hastur is an agent based model of quantitative trait evolution. 

## Tradeoffs and Design Decisions



### Selection

Fitness functions Mechanisms of selection

Example: On vs off (adaptation vs drift)

```{r}
#| echo: FALSE
#| output: FALSE
  
library(tidyverse)
library(purrr)
library(vroom)
library(pheatmap)
library(scales)
library(dplyr)
```

```{r}
#| echo: FALSE
#| output: FALSE

path <- "Hastur"
files <- list.files(path, pattern = "*.csv", full.names = TRUE)

all_the_data = data.frame()
for(csv in files){
  d <- read.csv(csv, as.is=T, header=T)
  sst <- t(as.data.frame(strsplit(csv, "")))
  d['file'] = csv
  d['Tower']=sst[1,8]
  d['replicate']=sst[1,11]


  
  P1Babies <- as.data.frame(table(as.factor(d$P1ID)))
  colnames(P1Babies)<-c("ID", "Babies1")
  P2Babies <- as.data.frame(table(as.factor(d$P2ID)))
  colnames(P2Babies)<-c("ID", "Babies2")
  d1<-merge(d,P1Babies, by = "ID", all=TRUE )
  d1[is.na(d1)] <- 0
  d2<-merge(d1, P2Babies, by = "ID", all=TRUE)
  d2[is.na(d2)] <- 0
  
  d2$Offspring <-d2$Babies1+d2$Babies2
  d2$relfit <- d2$Offspring/2
  d2<-subset(d2, ID > -1)
  
  all_the_data <- rbind(all_the_data, d2)
  print(csv)
}

all_the_data <- all_the_data %>%
  mutate(Evolution = 
           if_else(Tower == "X" | Tower == "Q" | Tower == "C"| Tower == "H", "OFF", "ON"))%>%
  mutate(Gun = if_else(Tower == "X" | Tower == "K" | Tower == "C", "Autocannon", "Chip Shredder"))%>%
  mutate(Civilians = if_else(Tower == "H" | Tower == "C", "ON", "OFF"))

df49 <- all_the_data %>%
  select(Generation, ID, AsexualReproduction, Fitness, Health, ColliderSurfaceArea,
         ScaleType0,
         SightRange, Armor, Damage, WalkSpeed, RunSpeed, Acceleration,
         TurnRate, Attraction0, Attraction1, Attraction2, file, Tower, replicate, Civilians,
         Offspring, relfit) %>%
  filter(Generation == 49)

Genavg <- all_the_data%>%
  group_by(Generation, Tower, replicate, Gun, Evolution, Civilians)%>%
  select(Generation, ID, AsexualReproduction, Fitness, Health, ColliderSurfaceArea,
         ScaleType0, SightRange, Armor, Damage, WalkSpeed, RunSpeed, Acceleration,
         TurnRate, Attraction0, Attraction1, Attraction2, file, Tower, replicate, Civilians,
         Offspring, relfit, Evolution, Gun) %>%
  summarize(across(c(Health, ColliderSurfaceArea, ScaleType0,
         SightRange, Armor, Damage, WalkSpeed, RunSpeed, Acceleration,
         TurnRate, Attraction0, Attraction1, Attraction2), mean))

```

```{r}
#| echo: FALSE

GenGun <- Genavg %>%
  filter(Civilians == "OFF")

GenCiv <- Genavg %>%
  filter(Evolution == "OFF")

ggplot(GenGun, aes(x=Generation, y= ColliderSurfaceArea))+
  geom_point(aes(x=Generation, y= ColliderSurfaceArea, color = Health))+
  geom_smooth()+
  facet_grid(Gun~Evolution)

ggplot(GenGun, aes(x=Generation, y= ScaleType0))+
  geom_point(aes(x=Generation, y= ScaleType0, color = ColliderSurfaceArea))+
  geom_smooth()+
  facet_grid(Gun~Evolution)+
  scale_color_gradient(low = muted("blue"),

  high = "red",

  space = "Lab",
  na.value = "grey50",
  guide = "colourbar",
  aesthetics = "colour")


ggplot(GenCiv, aes(x=Generation, y= ColliderSurfaceArea))+
  geom_point(aes(x=Generation, y= ColliderSurfaceArea, color = Health))+
  geom_smooth()+
  facet_grid(Gun~Civilians)

ggplot(GenCiv, aes(x=Generation, y= ScaleType0))+
  geom_point(aes(x=Generation, y= ScaleType0, color = ColliderSurfaceArea))+
  geom_smooth()+
  facet_grid(Gun~Civilians)+
  scale_color_gradient(low = muted("blue"),

  high = "red",

  space = "Lab",
  na.value = "grey50",
  guide = "colourbar",
  aesthetics = "colour")

  
```


```{r}
traittemp<-all_the_data%>%
  select(Generation, relfit, file, Evolution, Gun, Civilians, ScaleType0)%>%
  group_by(Generation, file, Evolution, Gun, Civilians)%>%
  mutate(scaleST0 = scale(ScaleType0, center = TRUE))%>%
  mutate(scaleST02 = scaleST0*scaleST0)

Gradients <- traittemp %>%
  group_by(Generation, file, Evolution, Gun, Civilians) %>%
  do({
    model <- lm(relfit ~ scaleST0 + scaleST02, data = .)
    data.frame(
      Beta = coefficients(model)[2],
      PB = summary(model)$coef[2, 4]
    )
  })

Gradients <- Gradients %>%
  mutate(sig = if_else(PB < 0.05 , "Y", "N"))

GunFit<- Gradients %>%
  filter(Civilians == "OFF")

CivFit<- Gradients %>%
  filter(Evolution == "OFF")

ggplot(GunFit, aes(x=Generation, y = Beta))+
  geom_point(aes(color = sig))+
  geom_smooth()+
  scale_color_manual(values = c("lightgrey","red"))+
  geom_hline(yintercept=0, linetype="dashed", color = "black")+
  theme(legend.position = "none")+
  facet_grid(Gun~Evolution)

ggplot(CivFit, aes(x=Generation, y = Beta))+
  geom_point(aes(color = sig))+
  geom_smooth()+
  scale_color_manual(values = c("lightgrey","red"))+
  geom_hline(yintercept=0, linetype="dashed", color = "black")+
  theme(legend.position = "none")+
  facet_grid(Gun~Civilians)

```

Hidden fitness functions

Example: Civilians and clonal reproduction.

```{r}
#| echo: FALSE
#| output: FALSE


files <- list.files(pattern = "*.csv", full.names = TRUE)

AutoCiv <- data.frame()
for(csv in files){
  d <- read.csv(csv, as.is=T, header=T)
  sst <- t(as.data.frame(strsplit(csv, "")))
  d['file'] = csv
  d['Tower']=sst[1,3]
  d['replicate']=sst[1,7]


  
  P1Babies <- as.data.frame(table(as.factor(d$P1ID)))
  colnames(P1Babies)<-c("ID", "Babies1")
  P2Babies <- as.data.frame(table(as.factor(d$P2ID)))
  colnames(P2Babies)<-c("ID", "Babies2")
  d1<-merge(d,P1Babies, by = "ID", all=TRUE )
  d1[is.na(d1)] <- 0
  d2<-merge(d1, P2Babies, by = "ID", all=TRUE)
  d2[is.na(d2)] <- 0
  
  d2$Offspring <-d2$Babies1+d2$Babies2
  d2$relfit <- d2$Offspring/2
  d2<-subset(d2, ID > -1)
  
  AutoCiv <- rbind(AutoCiv, d2)
  print(csv)
}

AutoCiv <- AutoCiv%>%
  mutate(Evolution = "ON")%>%
  mutate(Gun = "Autocannon")%>%
  mutate(Civilians = "ON")

AC49 <- AutoCiv %>%
  select(Generation, ID, AsexualReproduction, Fitness, Health, ColliderSurfaceArea, ScaleType0, SightRange, Armor, Damage, WalkSpeed, RunSpeed, Acceleration,TurnRate, Attraction0, Attraction1, Attraction2, file, Evolution, replicate, Civilians, Gun, Offspring, relfit) %>%
  filter(Generation == 49)

AutoGenAvg <- AutoCiv%>%
  group_by(Generation, Tower, replicate, Gun, Evolution, Civilians)%>%
  select(Generation, ID, AsexualReproduction, Fitness, Health, ColliderSurfaceArea, Gun,
         ScaleType0, SightRange, Armor, Damage, WalkSpeed, RunSpeed, Acceleration,
         TurnRate, Attraction0, Attraction1, Attraction2, file, replicate, Civilians,
         Offspring, relfit, Evolution, Gun) %>%
  summarize(across(c(Health, ColliderSurfaceArea, ScaleType0,
         SightRange, Armor, Damage, WalkSpeed, RunSpeed, Acceleration,
         TurnRate, Attraction0, Attraction1, Attraction2), mean))

ggplot(AutoCiv, aes(x=Generation, y= ColliderSurfaceArea))+
  geom_point(aes(x=Generation, y= ColliderSurfaceArea, color = SightRange))+
  geom_smooth()

ggplot(AutoCiv, aes(x=Generation, y= ScaleType0))+
  geom_point(aes(x=Generation, y= ScaleType0, color = SightRange),
             size=0.1, alpha = 0.1)+
  geom_smooth()+
  scale_color_gradient(low = muted("blue"),

  high = "red",

  space = "Lab",
  na.value = "grey50",
  guide = "colourbar",
  aesthetics = "colour")+
  facet_wrap(~replicate)

```

### Heatmap

```{r}
#| echo: FALSE


paletteLength <- 50
myColor <- colorRampPalette(c("blue", "white", "#ED2024"))(paletteLength)
# length(breaks) == length(paletteLength) + 1
# use floor and ceiling to deal with even/odd length pallettelengths

Heatmap<- AC49 %>%
  select(Health, ColliderSurfaceArea, 
         SightRange, Armor, Damage, WalkSpeed, RunSpeed, Acceleration,
         TurnRate, Attraction0, Attraction1, Attraction2, replicate)%>%
  group_by(replicate)%>%
  summarize_all(mean, na.rm = TRUE)



Heatscale<-Heatmap%>%
  transmute(across(c(Health, ColliderSurfaceArea, 
         SightRange, Armor, Damage, WalkSpeed, RunSpeed, Acceleration,
         TurnRate, Attraction0, Attraction1, Attraction2),
         scale))
  
Heatmatrix <- as.matrix(Heatscale)

rownames(Heatmatrix)<-Heatmap$replicate

myBreaks <- c(seq(min(Heatmatrix), 0, length.out=ceiling(paletteLength/2) + 1), 
              seq(max(Heatmatrix)/paletteLength, max(Heatmatrix), length.out=floor(paletteLength/2)))



# Sort your data by row names
Heatmatrix <- Heatmatrix[order(rownames(Heatmatrix)),]

# Generate the heatmap
pheatmap(Heatmatrix, 
         cluster_rows = TRUE, # don't cluster rows
         cluster_cols = TRUE, # don't cluster columns
         clustering_distance_cols = "euclidean", 
         clustering_distance_rows = "euclidean", 
         clustering_method = "complete",
         color = myColor, 
         breaks = myBreaks)



```

```{r}
ggplot(AutoCiv, aes(x=Generation, y= RunSpeed))+
  geom_point(aes(x=Generation, y= RunSpeed, color = Acceleration),
                 size = 0.1, alpha = 0.1)+
  geom_smooth()+
  scale_color_gradient(low = muted("blue"),

  high = "red",

  space = "Lab",
  na.value = "grey50",
  guide = "colourbar",
  aesthetics = "colour")+
  facet_wrap(~replicate)

```


```{r}
#| echo: FALSE


paletteLength <- 50
myColor <- colorRampPalette(c("blue", "white", "#ED2024"))(paletteLength)
# length(breaks) == length(paletteLength) + 1
# use floor and ceiling to deal with even/odd length pallettelengths

Heatmap<- AC49 %>%
  select(Health, ColliderSurfaceArea, 
         SightRange, Armor, Damage, WalkSpeed, RunSpeed, Acceleration,
         TurnRate, Attraction0, Attraction1, Attraction2, replicate)%>%
  filter(replicate==7)



Heatscale<-Heatmap%>%
  transmute(across(c(Health, ColliderSurfaceArea, 
         SightRange, Armor, Damage, WalkSpeed, RunSpeed, Acceleration,
         TurnRate, Attraction0, Attraction1, Attraction2),
         scale))
  
Heatmatrix <- as.matrix(Heatscale)

rownames(Heatmatrix)<-Heatmap$replicate

myBreaks <- c(seq(min(Heatmatrix), 0, length.out=ceiling(paletteLength/2) + 1), 
              seq(max(Heatmatrix)/paletteLength, max(Heatmatrix), length.out=floor(paletteLength/2)))



# Sort your data by row names
Heatmatrix <- Heatmatrix[order(rownames(Heatmatrix)),]

# Generate the heatmap
pheatmap(Heatmatrix, 
         cluster_rows = TRUE, # don't cluster rows
         cluster_cols = TRUE, # don't cluster columns
         clustering_distance_cols = "euclidean", 
         clustering_distance_rows = "euclidean", 
         clustering_method = "complete",
         color = myColor, 
         breaks = myBreaks)



```


Population Size: Performance Vs. Drift

Example: Genetic Drift and Effective Population Size


```{r}
Twin2<- read.csv("Twin/Gene_Write_File2.csv")
Twin1<- read.csv("Twin/geneWriteFile.csv")
Twin3<- read.csv("Twin/geneWriteFile1000.csv")


Twin3<-Twin3%>%
  mutate(Unique.Slime.ID = paste(Wave.Number, ".", Slime.ID))%>%
  mutate(Unique.Parent.One = paste(Wave.Number-1, ".", Parent.One))%>%
  mutate(Unique.Parent.Two = paste(Wave.Number-1, ".", Parent.Two))


df_parents <- Twin3 %>%
  select(Unique.Parent.One, Unique.Parent.Two) %>%
  pivot_longer(cols = everything(), names_to = "parent_type", values_to = "parent_id")

# Count the number of offspring for each parent
offspring_counts <- df_parents %>%
  group_by(parent_id) %>%
  summarise(offspring_count = n(), .groups = "drop")

offspring_counts <- offspring_counts%>%
  filter(parent_id != "-1 . N/A")


offspring_counts<- rename(offspring_counts, Unique.Slime.ID = parent_id)



Twin3 <- Twin3 %>%
  left_join(offspring_counts, by = "Unique.Slime.ID")%>%
  replace_na(list(offspring_count = 0))

Twin3counts<-Twin3%>%
  group_by(Main.Type, Wave.Number)%>%
  summarise(mean_Speed = mean(Speed.Trait, na.rm = TRUE), 
            mean_Resist = mean(Main.Resistance.Trait, na.rm = TRUE), 
            count = n())

ggplot(Twin3counts, aes(x = Wave.Number, y = count, fill = as.factor(Main.Type))) +
  geom_col(position = "stack") +
  labs(x = "Generation", y = "Count", fill = "Main Slime Type") +
  theme_minimal()


ggplot(Twin3, aes(x=Wave.Number, y= Main.Resistance.Trait))+
  geom_point(aes(x=Wave.Number, y= Main.Resistance.Trait, color = offspring_count),
        size= 0.5,     alpha =0.2)+
  geom_smooth()+
  facet_wrap(~Main.Type)+
  scale_color_continuous(low="blue", high = "red")

ggplot(Twin3, aes(x=Wave.Number, y= Secondary.Resistance.Trait))+
  geom_point(aes(x=Wave.Number, y= Secondary.Resistance.Trait, color = offspring_count),
        size= 0.5,     alpha =0.2)+
  geom_smooth()+
  facet_wrap(~Main.Type)+
  scale_color_continuous(low="blue", high = "red")


ggplot(Twin3, aes(x=Wave.Number, y= Tower.Attraction.Trait))+
  geom_point(aes(x=Wave.Number, y= Tower.Attraction.Trait, color = offspring_count),
        size= 0.5,     alpha =0.2)+
  geom_smooth()+
  facet_wrap(~Main.Type)+
  scale_color_continuous(low="blue", high = "red")

ggplot(Twin3, aes(x=Wave.Number, y= Slime.Optimal.Distance.Trait))+
  geom_point(aes(x=Wave.Number, y= Slime.Optimal.Distance.Trait, color = offspring_count),
        size= 0.5,     alpha =0.2)+
  geom_smooth()+
  facet_wrap(~Main.Type)+
  scale_color_continuous(low="blue", high = "red")

ggplot(Twin3, aes(x=Wave.Number, y= Speed.Trait))+
  geom_point(aes(x=Wave.Number, y= Speed.Trait, color = offspring_count),
        size= 0.5,     alpha =0.2)+
  geom_smooth()+
  facet_wrap(~Main.Type)+
  scale_color_continuous(low="blue", high = "red")


ggplot(Twin3, aes(x=Wave.Number, y= Turn.Rate.Trait))+
  geom_point(aes(x=Wave.Number, y= Turn.Rate.Trait, color = offspring_count),
        size= 0.5,     alpha =0.2)+
  geom_smooth()+
  facet_wrap(~Main.Type)+
  scale_color_continuous(low="blue", high = "red")

ggplot(Twin3, aes(x=Wave.Number, y= Slime.View.Range.Trait))+
  geom_point(aes(x=Wave.Number, y= Slime.View.Range.Trait, color = offspring_count),
        size= 0.5,     alpha =0.2)+
  geom_smooth()+
  facet_wrap(~Main.Type)+
  scale_color_continuous(low="blue", high = "red")

ggplot(Twin3, aes(x=Wave.Number, y= Tower.View.Range.Trait))+
  geom_point(aes(x=Wave.Number, y= Tower.View.Range.Trait, color = offspring_count),
        size= 0.5,     alpha =0.2)+
  geom_smooth()+
  facet_wrap(~Main.Type)+
  scale_color_continuous(low="blue", high = "red")

ggplot(Twin3, aes(x=Wave.Number, y= Player.Distance.Fitness))+
  geom_point(aes(x=Wave.Number, y= Player.Distance.Fitness, color = offspring_count),
        size= 0.5,     alpha =0.2)+
  geom_smooth()+
  facet_wrap(~Main.Type)+
  scale_color_continuous(low="blue", high = "red")


Twin2Lightning <- Twin2 %>%
  filter(Main.Type == "Lightning" | Secondary.Type == "Lightning")

ggplot(Twin2Lightning, aes(x=Wave.Number, y= Tower.Attraction.Trait))+
  geom_point(aes(x=Wave.Number, y= Tower.Attraction.Trait),
             size=0.5, alpha = 0.5)+
  geom_smooth()

Twin2counts<-Twin2%>%
  group_by(Main.Type, Wave.Number)%>%
  summarise(mean_Speed = mean(Speed.Trait, na.rm = TRUE), 
            mean_Resist = mean(Main.Resistance.Trait, na.rm = TRUE), 
            count = n())

ggplot(Twin2counts, aes(x = Wave.Number, y = count, fill = as.factor(Main.Type))) +
  geom_col(position = "stack") +
  labs(x = "Generation", y = "Count", fill = "Main Slime Type") +
  theme_minimal()


```


```{r}
#| eval: false

LastGen <- Twin3

LastGen <- Twin3 %>%
  select(Wave.Number, Slime.ID, Player.Distance.Fitness, Main.Resistance.Trait, Secondary.Resistance.Trait, Slime.View.Range.Trait, 
         Tower.View.Range.Trait, Player.View.Range.Trait, Wall.View.Range.Trait, Sheep.View.Range.Trait, Slime.Attraction.Trait, 
         Tower.Attraction.Trait, Player.Attraction.Trait, Wall.Attraction.Trait, Sheep.Attraction.Trait, Slime.Optimal.Distance.Trait, 
         Speed.Trait, Turn.Rate.Trait, Sprint.Duration.Trait, Sprint.Cooldown.Trait, offspring_count) %>%
  filter(Wave.Number == 35)


paletteLength <- 50
myColor <- colorRampPalette(c("blue", "white", "#ED2024"))(paletteLength)
# length(breaks) == length(paletteLength) + 1
# use floor and ceiling to deal with even/odd length pallettelengths


Heatmap2 <- LastGen %>%
  select(Player.Distance.Fitness, Main.Resistance.Trait, Secondary.Resistance.Trait, Slime.View.Range.Trait, 
         Tower.View.Range.Trait, Player.View.Range.Trait, Wall.View.Range.Trait, Sheep.View.Range.Trait, Slime.Attraction.Trait, 
         Tower.Attraction.Trait, Player.Attraction.Trait, Wall.Attraction.Trait, Sheep.Attraction.Trait, Slime.Optimal.Distance.Trait, 
         Speed.Trait, Turn.Rate.Trait, Sprint.Duration.Trait, Sprint.Cooldown.Trait)

Heatmap2[,1:18]<- scale(Heatmap2[,1:18])

colnames(Heatmap2) <- c('Fitness', 'Main Resistance', 'Secondary Resistance', 'Slime View Range', 'Tower Viewe Range', 'Player View Range', 
                        'Wall View Range', 'Sheep View Range', 'Slime Attraction', 'Tower Attraction', 'Player Attraction', 'Wall Attraction',
                        'Sheep Attraction', 'Slime Optimal Distance', 'Speed', 'Turn Rate', 'Sprint Duration', 'Sprint Cooldown')
  
Heatmatrix2 <- as.matrix(Heatmap2)

myBreaks2 <- c(seq(min(Heatmatrix2), 0, length.out=ceiling(paletteLength/2) + 1), seq(max(Heatmatrix2)/paletteLength, max(Heatmatrix2), length.out=floor(paletteLength/2)))

# Generate the heatmap
pheatmap(Heatmatrix2, 
         cluster_rows = TRUE, # don't cluster rows
         cluster_cols = TRUE, # don't cluster columns
         clustering_distance_cols = "euclidean", 
         clustering_distance_rows = "euclidean", 
         clustering_method = "complete",
         cellheight = 0.75,
         fontsize_col = 10,
         color = myColor,
         breaks = myBreaks2)

```


```{r}
traittemp.Twin<-Twin3%>%
  select(Wave.Number, offspring_count, Slime.Optimal.Distance.Trait)%>%
  group_by(Wave.Number)%>%
  mutate(Trait = scale(Slime.Optimal.Distance.Trait, center = TRUE))%>%
  mutate(Trait2 = Trait*Trait)

Gradients <- traittemp.Twin %>%
  group_by(Wave.Number)%>%
  do({
    model <- lm(offspring_count ~ Trait + Trait2, data = .)
    data.frame(
      Beta = coefficients(model)[2],
      PB = summary(model)$coef[2, 4]
    )
  })

Gradients <- Gradients %>%
  mutate(sig = if_else(PB < 0.05 , "Y", "N"))



ggplot(Gradients, aes(x=Wave.Number, y = Beta))+
  geom_point(aes(color = sig))+
  geom_smooth()+
  scale_color_manual(values = c("lightgrey","red"))+
  geom_hline(yintercept=0, linetype="dashed", color = "black")+
  theme(legend.position = "none")

# ggplot(Twin3, aes(x = Player.Distance.Fitness)) +
#   geom_histogram(binwidth = 1000, fill = 'blue', color = 'black') +
#   labs(x = "Variable Name", y = "Frequency") +
#   theme_minimal()+
#   facet_wrap(~Wave.Number)

```

#### Time

The concept of time in video games is often defined in terms of waves or levels. Both of these terms imply a progression toward the game's goal, along with a corresponding increase in difficulty. In our games, we usually specify time in terms of generations. A wave of enemies begin the game, the player defeats them, and then the next wave is created with Inheritance using a mating function specified as described above. As the generations (waves) proceed, the enemies with traits that are best able to optimize the fitness functions have more offspring, and the population adapts to the game play conditions. Most of these conditions are created by player choices and playstyle, and thus the enemies adapt to the player. Difficulty increases organically and repeated gameplay often creates novel adaptive solutions to the same play style.




### Evolutionary Model
### Time

Generational model = waves

Continuous model

### Educational Outcomes

We reasoned that playing these types of games might have implications for STEM education. The success of the player is based on her comprehension and application of principles of evolutionary biology. The parallels to real world examples are numerous, and include the rapid evolution of antibiotic resistance in microbial pathogens, adaptation of crop pests to chemical and biological control measures, and behavioral adaptation to captivity in domesticated animals.

Adding biological evolution to video games makes the games better for the game player and facilitates player comprehension of complex concepts that are hard to teach.


